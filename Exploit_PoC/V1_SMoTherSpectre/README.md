# Spectre-v1 type SMoTherSpectre Attack
SMoTherSpectre attack utilizes the resource contention (port) between htyper-threads to leak secret via spectre-v2 attack.  
Based on the hardware resource contention between two hyper-threads, we build our Spectre-v1 type SMotherSpectre Attack.  

The main contribution of our Spectre-v1 type SMotherSpectre attack is to reveal and prove that an inner secret relevant branch leaks secret under speculative execution even with the presence of Speculative Load Hardening.  

We claim that Spectre-v1 SMotherSpectre can bypass SLH not because the way it implementents, but the principle behinds it: 

**What can leak secrets.**


## Secret-relevant Branch
In the PoC, we construct such gadget which has a security check before going to secret-relevant processings which involve secret relevant branches.

The security check branch is bypassed speculatively, and the inner secret relevant branch is also trained during attacker's training procedure.

To extend the speculative window, we delay the security check, however the inner branch is not delayed.  
Therefore, the inner branch is resolved much faster than the security check branch.  
We perform SMoTher attack to check which branch is taken.  

SMotherSpectre attack is not the only way to leak which secret relevant branch is taken. The secret path can also be leaked via public memory access, Reorder buffer size limitation.

## Bypassing SLH
SLH hardens memory access, however it does not harden variables that is already fetched in safe states (correct prediction) but is used in unsafe states (misprediction).

Therefore if a branch condition is already fetched safely and it remains in a register, SLH does not harden it.

## Fixing SLH
To fix this limitation of SLH, we harden all flag setting instruction.

## How to run it
Please refer to compile.bash.  
We also provide the c code version. You could compile it with GCC to see leakages.

